package de.voelter.mps.naming.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.AttributesRolesUtil;
import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.smodel.SModelUtil_new;

public class check_IQualifiedNamedConcept_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_IQualifiedNamedConcept_NonTypesystemRule() {
  }

  public void applyRule(final SNode qc, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    SNode concept = SNodeOperations.getConceptDeclaration(qc);
    for (SNode ld : ListSequence.fromList(SLinkOperations.getTargets(concept, "linkDeclaration", true))) {
      if ((SLinkOperations.getTarget(ld, AttributesRolesUtil.childRoleFromAttributeRole("uniqueNamesConstraintAnnotation"), true) != null)) {
        List<SNode> children = SNodeOperations.getChildren(qc, ld);
        Set<String> names = SetSequence.fromSet(new HashSet<String>());
        for (SNode n : ListSequence.fromList(children)) {
          if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.lang.core.structure.INamedConcept")) {
            String name = SPropertyOperations.getString(SNodeOperations.cast(n, "jetbrains.mps.lang.core.structure.INamedConcept"), "name");
            if (SetSequence.fromSet(names).contains(name)) {
              {
                MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(n, "duplicate name", "r:84f8b1a0-9e9a-41fe-83cb-83da03a2e049(de.voelter.mps.naming.typesystem)", "5019556274771898168", null, errorTarget);
              }
            } else {
              SetSequence.fromSet(names).addElement(name);
            }
          }
        }
      }
    }
  }

  public String getApplicableConceptFQName() {
    return "de.voelter.mps.naming.structure.IQualifiedNamedConcept";
  }

  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    {
      boolean b = SModelUtil_new.isAssignableConcept(argument.getConceptFqName(), this.getApplicableConceptFQName());
      return new IsApplicableStatus(b, null);
    }
  }

  public boolean overrides() {
    return false;
  }
}
